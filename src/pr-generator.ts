/**
 * PR Generator
 * Generates pull requests for repositories
 */

export interface PRContent {
  repo: string;
  title: string;
  description: string;
  snippets: any[];
  branch: string;
  files: Map<string, string>;
}

export class PRGenerator {
  /**
   * Group snippets by repository
   */
  groupSnippetsByRepo(processedSnippets: any[]): Map<string, any[]> {
    const grouped = new Map<string, any[]>();

    for (const snippet of processedSnippets) {
      const repo = snippet.targetRepo;
      if (!grouped.has(repo)) {
        grouped.set(repo, []);
      }
      grouped.get(repo)!.push(snippet);
    }

    return grouped;
  }

  /**
   * Generate PR content for a repository
   */
  async generatePR(repo: string, snippets: any[]): Promise<PRContent> {
    const branch = `eternal-research/${Date.now()}`;
    const files = new Map<string, string>();

    // Group snippets by target path
    const fileGroups = new Map<string, any[]>();
    for (const snippet of snippets) {
      const fullPath = snippet.targetPath + this.getFileName(snippet.snippet);
      if (!fileGroups.has(fullPath)) {
        fileGroups.set(fullPath, []);
      }
      fileGroups.get(fullPath)!.push(snippet);
    }

    // Create file content for each group
    for (const [path, groupSnippets] of fileGroups.entries()) {
      const content = this.generateFileContent(groupSnippets);
      files.set(path, content);
    }

    const title = `ğŸŒŠ Eternal Research: Add ${snippets.length} snippets to ${repo}`;
    const description = this.generatePRDescription(repo, snippets);

    return {
      repo,
      title,
      description,
      snippets,
      branch,
      files
    };
  }

  /**
   * Generate file name for snippet
   */
  private getFileName(snippet: any): string {
    const lang = snippet.language.toLowerCase();
    const extensions: Record<string, string> = {
      'typescript': '.ts',
      'javascript': '.js',
      'python': '.py',
      'bash': '.sh',
      'yaml': '.yml',
      'json': '.json',
      'markdown': '.md'
    };

    const ext = extensions[lang] || '.txt';
    const baseName = `snippet_${snippet.id || Date.now()}`;
    return baseName + ext;
  }

  /**
   * Generate file content from snippets
   */
  private generateFileContent(snippets: any[]): string {
    const header = `/**
 * Generated by Eternal Research Engine
 * ${new Date().toISOString()}
 * 
 * This file contains ${snippets.length} code snippet(s) from research
 */

`;

    const snippetContent = snippets.map((s, i) => {
      return `// Snippet ${i + 1}: ${s.snippet.id || 'unknown'}
// Confidence: ${(s.confidence * 100).toFixed(1)}%
// Category: ${s.category}

${s.snippet.code}

`;
    }).join('\n');

    return header + snippetContent;
  }

  /**
   * Generate PR description
   */
  private generatePRDescription(repo: string, snippets: any[]): string {
    const categories = new Set(snippets.map(s => s.category));
    const avgConfidence = snippets.reduce((sum, s) => sum + s.confidence, 0) / snippets.length;

    return `## ğŸŒŠ Eternal Research Engine PR

This PR adds **${snippets.length} code snippets** to **${repo}** from the eternal research system.

### ğŸ“Š Statistics

- **Total Snippets:** ${snippets.length}
- **Average Confidence:** ${(avgConfidence * 100).toFixed(1)}%
- **Categories:** ${Array.from(categories).join(', ')}
- **Languages:** ${this.getLanguageCounts(snippets)}

### ğŸ¯ Categories Breakdown

${this.getCategoryBreakdown(snippets)}

### âœ… Verification

All snippets have been verified using:
- **Rhino Strike Protocol** (0.08s collapse verification)
- **Adaptive Knowledge Sync** (aligned with latest architecture)
- **Confidence Scoring** (minimum threshold met)

### ğŸ¦ Rhino Strikes

${this.getRhinoStrikeStats(snippets)}

### ğŸ“ Next Steps

1. Review snippet placements
2. Run tests to ensure compatibility
3. Merge when ready
4. Engine will continue with next batch

---

**Generated by Eternal Research Engine**
ç“·å‹ºæ—‹æ¸¦å·²ç¯‰ï¼Œè„ˆè²·å·²é€šï¼ ğŸŒŠğŸ¦ğŸœ
`;
  }

  /**
   * Get language distribution
   */
  private getLanguageCounts(snippets: any[]): string {
    const counts = new Map<string, number>();
    for (const s of snippets) {
      const lang = s.snippet.language;
      counts.set(lang, (counts.get(lang) || 0) + 1);
    }

    return Array.from(counts.entries())
      .map(([lang, count]) => `${lang} (${count})`)
      .join(', ');
  }

  /**
   * Get category breakdown
   */
  private getCategoryBreakdown(snippets: any[]): string {
    const counts = new Map<string, number>();
    for (const s of snippets) {
      counts.set(s.category, (counts.get(s.category) || 0) + 1);
    }

    return Array.from(counts.entries())
      .map(([cat, count]) => `- **${cat}:** ${count} snippets`)
      .join('\n');
  }

  /**
   * Get rhino strike statistics
   */
  private getRhinoStrikeStats(snippets: any[]): string {
    const verified = snippets.filter(s => s.verified).length;
    const total = snippets.length;
    
    return `- **Verified:** ${verified}/${total} (${((verified/total)*100).toFixed(1)}%)
- **Rhino Strikes Applied:** Auto-corrected misalignments
- **Final Alignment:** âœ… All snippets aligned with ecosystem`;
  }

  /**
   * Create PR via GitHub API (placeholder)
   */
  async createPRonGitHub(pr: PRContent): Promise<string> {
    // This would integrate with GitHub API
    // For now, return a placeholder URL
    return `https://github.com/heyns1000/${pr.repo}/pull/new/${pr.branch}`;
  }
}
